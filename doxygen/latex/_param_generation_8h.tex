\hypertarget{_param_generation_8h}{}\section{P\+I\+V\+X/src/libzerocoin/\+Param\+Generation.h File Reference}
\label{_param_generation_8h}\index{P\+I\+V\+X/src/libzerocoin/\+Param\+Generation.\+h@{P\+I\+V\+X/src/libzerocoin/\+Param\+Generation.\+h}}


Parameter generation routines for Zerocoin.  


{\ttfamily \#include \char`\"{}Params.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_param_generation_8h_af7460110027bf2977ccfc3af939820b5}\label{_param_generation_8h_af7460110027bf2977ccfc3af939820b5}} 
\#define {\bfseries S\+T\+R\+I\+N\+G\+\_\+\+C\+O\+M\+M\+I\+T\+\_\+\+G\+R\+O\+UP}~\char`\"{}C\+O\+I\+N\+\_\+\+C\+O\+M\+M\+I\+T\+M\+E\+N\+T\+\_\+\+G\+R\+O\+UP\char`\"{}
\item 
\mbox{\Hypertarget{_param_generation_8h_aa287b314132f77edbcadae6851c55f13}\label{_param_generation_8h_aa287b314132f77edbcadae6851c55f13}} 
\#define {\bfseries S\+T\+R\+I\+N\+G\+\_\+\+A\+V\+C\+\_\+\+G\+R\+O\+UP}~\char`\"{}A\+C\+C\+U\+M\+U\+L\+A\+T\+E\+D\+\_\+\+V\+A\+L\+U\+E\+\_\+\+C\+O\+M\+M\+I\+T\+M\+E\+N\+T\+\_\+\+G\+R\+O\+UP\char`\"{}
\item 
\mbox{\Hypertarget{_param_generation_8h_ac5da63f87ac062ee7c2ab8a3bc388a67}\label{_param_generation_8h_ac5da63f87ac062ee7c2ab8a3bc388a67}} 
\#define {\bfseries S\+T\+R\+I\+N\+G\+\_\+\+A\+V\+C\+\_\+\+O\+R\+D\+ER}~\char`\"{}A\+C\+C\+U\+M\+U\+L\+A\+T\+E\+D\+\_\+\+V\+A\+L\+U\+E\+\_\+\+C\+O\+M\+M\+I\+T\+M\+E\+N\+T\+\_\+\+O\+R\+D\+ER\char`\"{}
\item 
\mbox{\Hypertarget{_param_generation_8h_a02c30c0ae40d6170dcd1188a0c30a8df}\label{_param_generation_8h_a02c30c0ae40d6170dcd1188a0c30a8df}} 
\#define {\bfseries S\+T\+R\+I\+N\+G\+\_\+\+A\+I\+C\+\_\+\+G\+R\+O\+UP}~\char`\"{}A\+C\+C\+U\+M\+U\+L\+A\+T\+O\+R\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+C\+O\+M\+M\+I\+T\+M\+E\+N\+T\+\_\+\+G\+R\+O\+UP\char`\"{}
\item 
\mbox{\Hypertarget{_param_generation_8h_a26d0543f2143b5ec2c2d30c0bc8ac368}\label{_param_generation_8h_a26d0543f2143b5ec2c2d30c0bc8ac368}} 
\#define {\bfseries S\+T\+R\+I\+N\+G\+\_\+\+Q\+R\+N\+C\+O\+M\+M\+I\+T\+\_\+\+G\+R\+O\+U\+PG}~\char`\"{}A\+C\+C\+U\+M\+U\+L\+A\+T\+O\+R\+\_\+\+Q\+R\+N\+\_\+\+C\+O\+M\+M\+I\+T\+M\+E\+N\+T\+\_\+\+G\+R\+O\+U\+PG\char`\"{}
\item 
\mbox{\Hypertarget{_param_generation_8h_ae8d48379020ad26a376f16d5ec8dd2e7}\label{_param_generation_8h_ae8d48379020ad26a376f16d5ec8dd2e7}} 
\#define {\bfseries S\+T\+R\+I\+N\+G\+\_\+\+Q\+R\+N\+C\+O\+M\+M\+I\+T\+\_\+\+G\+R\+O\+U\+PH}~\char`\"{}A\+C\+C\+U\+M\+U\+L\+A\+T\+O\+R\+\_\+\+Q\+R\+N\+\_\+\+C\+O\+M\+M\+I\+T\+M\+E\+N\+T\+\_\+\+G\+R\+O\+U\+PH\char`\"{}
\item 
\mbox{\Hypertarget{_param_generation_8h_acba99dd4ca0c7b7989aab2a0938c035a}\label{_param_generation_8h_acba99dd4ca0c7b7989aab2a0938c035a}} 
\#define {\bfseries A\+C\+C\+U\+M\+U\+L\+A\+T\+O\+R\+\_\+\+B\+A\+S\+E\+\_\+\+C\+O\+N\+S\+T\+A\+NT}~31
\item 
\mbox{\Hypertarget{_param_generation_8h_a9c12438e264173a1ecb6741795eb5ef3}\label{_param_generation_8h_a9c12438e264173a1ecb6741795eb5ef3}} 
\#define {\bfseries M\+A\+X\+\_\+\+P\+R\+I\+M\+E\+G\+E\+N\+\_\+\+A\+T\+T\+E\+M\+P\+TS}~10000
\item 
\mbox{\Hypertarget{_param_generation_8h_a9a5cba3fd211340d2afcf9677b470ab9}\label{_param_generation_8h_a9a5cba3fd211340d2afcf9677b470ab9}} 
\#define {\bfseries M\+A\+X\+\_\+\+A\+C\+C\+U\+M\+G\+E\+N\+\_\+\+A\+T\+T\+E\+M\+P\+TS}~10000
\item 
\mbox{\Hypertarget{_param_generation_8h_a64252da1effb57af37dc7047670acc7a}\label{_param_generation_8h_a64252da1effb57af37dc7047670acc7a}} 
\#define {\bfseries M\+A\+X\+\_\+\+G\+E\+N\+E\+R\+A\+T\+O\+R\+\_\+\+A\+T\+T\+E\+M\+P\+TS}~10000
\item 
\mbox{\Hypertarget{_param_generation_8h_adbb58a82940c01dee60a8a1896494e09}\label{_param_generation_8h_adbb58a82940c01dee60a8a1896494e09}} 
\#define {\bfseries N\+U\+M\+\_\+\+S\+C\+H\+N\+O\+R\+R\+G\+E\+N\+\_\+\+A\+T\+T\+E\+M\+P\+TS}~10000
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{_param_generation_8h_a93fd38e59e0730f9b7417c389e9fcab5}\label{_param_generation_8h_a93fd38e59e0730f9b7417c389e9fcab5}} 
void {\bfseries libzerocoin\+::\+Calculate\+Params} (Zerocoin\+Params \&params, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} N, std\+::string aux, uint32\+\_\+t security\+Level)
\item 
void \mbox{\hyperlink{_param_generation_8cpp_af84d8d406285f665c4e8c60443a57c97}{libzerocoin\+::calculate\+Group\+Param\+Lengths}} (uint32\+\_\+t max\+P\+Len, uint32\+\_\+t security\+Level, uint32\+\_\+t $\ast$p\+Len, uint32\+\_\+t $\ast$q\+Len)
\begin{DoxyCompactList}\small\item\em Calculate field/group parameter sizes based on a security level. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{_param_generation_8cpp_aeda115c7208be9405f951779ec131494}{libzerocoin\+::primality\+Test\+By\+Trial\+Division}} (uint32\+\_\+t candidate)
\begin{DoxyCompactList}\small\item\em Determines whether a uint32\+\_\+t is a prime through trial division. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{_param_generation_8h_a40cabf73335c9e8a0e111de086919aef}\label{_param_generation_8h_a40cabf73335c9e8a0e111de086919aef}} 
\mbox{\hyperlink{classuint256}{uint256}} {\bfseries libzerocoin\+::calculate\+Seed} (\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} modulus, std\+::string aux\+String, uint32\+\_\+t security\+Level, std\+::string group\+Name)
\item 
\mbox{\Hypertarget{_param_generation_8h_acf5ef9b8ee93d665d00051cc8b4d9970}\label{_param_generation_8h_acf5ef9b8ee93d665d00051cc8b4d9970}} 
\mbox{\hyperlink{classuint256}{uint256}} {\bfseries libzerocoin\+::calculate\+Generator\+Seed} (\mbox{\hyperlink{classuint256}{uint256}} seed, \mbox{\hyperlink{classuint256}{uint256}} p\+Seed, \mbox{\hyperlink{classuint256}{uint256}} q\+Seed, std\+::string label, uint32\+\_\+t index, uint32\+\_\+t count)
\item 
\mbox{\Hypertarget{_param_generation_8cpp_a2ab9735f14a3fdcdf18e0fd410a6e701}\label{_param_generation_8cpp_a2ab9735f14a3fdcdf18e0fd410a6e701}} 
\mbox{\hyperlink{classuint256}{uint256}} {\bfseries libzerocoin\+::calculate\+Hash} (\mbox{\hyperlink{classuint256}{uint256}} input)
\item 
Integer\+Group\+Params \mbox{\hyperlink{_param_generation_8cpp_a104c1a4d313174893b0de7595bfa7baa}{libzerocoin\+::derive\+Integer\+Group\+Params}} (\mbox{\hyperlink{classuint256}{uint256}} seed, uint32\+\_\+t p\+Len, uint32\+\_\+t q\+Len)
\begin{DoxyCompactList}\small\item\em Deterministically compute a set of group parameters using N\+I\+ST procedures. \end{DoxyCompactList}\item 
Integer\+Group\+Params \mbox{\hyperlink{_param_generation_8cpp_a8d4a084866f5f0598e39704cedb96959}{libzerocoin\+::derive\+Integer\+Group\+From\+Order}} (\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \&group\+Order)
\begin{DoxyCompactList}\small\item\em Deterministically compute a set of group parameters with a specified order. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_param_generation_8cpp_ae993b839bf47f3e64151b39abd3a5c08}{libzerocoin\+::calculate\+Group\+Modulus\+And\+Order}} (\mbox{\hyperlink{classuint256}{uint256}} seed, uint32\+\_\+t p\+Len, uint32\+\_\+t q\+Len, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$result\+Modulus, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$result\+Group\+Order, \mbox{\hyperlink{classuint256}{uint256}} $\ast$result\+Pseed, \mbox{\hyperlink{classuint256}{uint256}} $\ast$result\+Qseed)
\begin{DoxyCompactList}\small\item\em Deterministically compute a group description using N\+I\+ST procedures. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \mbox{\hyperlink{_param_generation_8cpp_a99d5082673d5c4e4d0f629f986636946}{libzerocoin\+::calculate\+Group\+Generator}} (\mbox{\hyperlink{classuint256}{uint256}} seed, \mbox{\hyperlink{classuint256}{uint256}} p\+Seed, \mbox{\hyperlink{classuint256}{uint256}} q\+Seed, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} modulus, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} group\+Order, uint32\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Deterministically compute a generator for a given group. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \mbox{\hyperlink{_param_generation_8cpp_a2099b8bbbed1501554a9be21e74b9254}{libzerocoin\+::generate\+Random\+Prime}} (uint32\+\_\+t prime\+Bit\+Len, \mbox{\hyperlink{classuint256}{uint256}} in\+\_\+seed, \mbox{\hyperlink{classuint256}{uint256}} $\ast$out\+\_\+seed, uint32\+\_\+t $\ast$prime\+\_\+gen\+\_\+counter)
\begin{DoxyCompactList}\small\item\em Deterministically compute a random prime number. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{_param_generation_8cpp_a6f07f95c6873008f19659311147e7a41}\label{_param_generation_8cpp_a6f07f95c6873008f19659311147e7a41}} 
\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} {\bfseries libzerocoin\+::generate\+Integer\+From\+Seed} (uint32\+\_\+t num\+Bits, \mbox{\hyperlink{classuint256}{uint256}} seed, uint32\+\_\+t $\ast$num\+Iterations)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Parameter generation routines for Zerocoin. 

\begin{DoxyAuthor}{Author}
Ian Miers, Christina Garman and Matthew Green 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
June 2013
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright 2013 Ian Miers, Christina Garman and Matthew Green  This project is released under the M\+IT license. 
\end{DoxyCopyright}


\subsection{Function Documentation}
\mbox{\Hypertarget{_param_generation_8cpp_file_a99d5082673d5c4e4d0f629f986636946}\label{_param_generation_8cpp_file_a99d5082673d5c4e4d0f629f986636946}} 
\index{Param\+Generation.\+h@{Param\+Generation.\+h}!calculate\+Group\+Generator@{calculate\+Group\+Generator}}
\index{calculate\+Group\+Generator@{calculate\+Group\+Generator}!Param\+Generation.\+h@{Param\+Generation.\+h}}
\subsubsection{\texorpdfstring{calculate\+Group\+Generator()}{calculateGroupGenerator()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} libzerocoin\+::calculate\+Group\+Generator (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{p\+Seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{q\+Seed,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}}}]{modulus,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}}}]{group\+Order,  }\item[{uint32\+\_\+t}]{index }\end{DoxyParamCaption})}



Deterministically compute a generator for a given group. 


\begin{DoxyParams}{Parameters}
{\em seed} & A first seed for the process. \\
\hline
{\em p\+Seed} & A second seed for the process. \\
\hline
{\em q\+Seed} & A third seed for the process. \\
\hline
{\em modulus} & Proposed prime modulus for the field. \\
\hline
{\em group\+Order} & Proposed order of the group. \\
\hline
{\em index} & Index value, selects which generator you\textquotesingle{}re building. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The resulting generator. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em A} & std\+::runtime\+\_\+error if error.\\
\hline
\end{DoxyExceptions}
Generates a random group generator deterministically as a function of (seed,p\+Seed,q\+Seed) Uses the algorithm described in F\+I\+PS 186-\/3 Appendix A.\+2.\+3. \mbox{\Hypertarget{_param_generation_8cpp_file_ae993b839bf47f3e64151b39abd3a5c08}\label{_param_generation_8cpp_file_ae993b839bf47f3e64151b39abd3a5c08}} 
\index{Param\+Generation.\+h@{Param\+Generation.\+h}!calculate\+Group\+Modulus\+And\+Order@{calculate\+Group\+Modulus\+And\+Order}}
\index{calculate\+Group\+Modulus\+And\+Order@{calculate\+Group\+Modulus\+And\+Order}!Param\+Generation.\+h@{Param\+Generation.\+h}}
\subsubsection{\texorpdfstring{calculate\+Group\+Modulus\+And\+Order()}{calculateGroupModulusAndOrder()}}
{\footnotesize\ttfamily void libzerocoin\+::calculate\+Group\+Modulus\+And\+Order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{seed,  }\item[{uint32\+\_\+t}]{p\+Len,  }\item[{uint32\+\_\+t}]{q\+Len,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$}]{result\+Modulus,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$}]{result\+Group\+Order,  }\item[{\mbox{\hyperlink{classuint256}{uint256}} $\ast$}]{result\+Pseed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}} $\ast$}]{result\+Qseed }\end{DoxyParamCaption})}



Deterministically compute a group description using N\+I\+ST procedures. 


\begin{DoxyParams}{Parameters}
{\em seed} & A byte string seeding the process. \\
\hline
{\em p\+Len} & The desired length of the modulus \char`\"{}p\char`\"{} in bits \\
\hline
{\em q\+Len} & The desired length of the order \char`\"{}q\char`\"{} in bits \\
\hline
{\em result\+Modulus} & A value \char`\"{}p\char`\"{} describing a finite field \char`\"{}\+F\+\_\+p\char`\"{} \\
\hline
{\em result\+Group\+Order} & A value \char`\"{}q\char`\"{} describing the order of a subgroup \\
\hline
{\em result\+Domain\+Parameter\+Seed} & A resulting seed for use in later calculations.\\
\hline
\end{DoxyParams}
Calculates the description of a group G of prime order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. The input to this routine is in arbitrary seed. It uses the algorithms described in F\+I\+PS 186-\/3 Appendix A.\+1.\+2 to calculate primes \char`\"{}p\char`\"{} and \char`\"{}q\char`\"{}. \mbox{\Hypertarget{_param_generation_8cpp_file_af84d8d406285f665c4e8c60443a57c97}\label{_param_generation_8cpp_file_af84d8d406285f665c4e8c60443a57c97}} 
\index{Param\+Generation.\+h@{Param\+Generation.\+h}!calculate\+Group\+Param\+Lengths@{calculate\+Group\+Param\+Lengths}}
\index{calculate\+Group\+Param\+Lengths@{calculate\+Group\+Param\+Lengths}!Param\+Generation.\+h@{Param\+Generation.\+h}}
\subsubsection{\texorpdfstring{calculate\+Group\+Param\+Lengths()}{calculateGroupParamLengths()}}
{\footnotesize\ttfamily void libzerocoin\+::calculate\+Group\+Param\+Lengths (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{max\+P\+Len,  }\item[{uint32\+\_\+t}]{security\+Level,  }\item[{uint32\+\_\+t $\ast$}]{p\+Len,  }\item[{uint32\+\_\+t $\ast$}]{q\+Len }\end{DoxyParamCaption})}



Calculate field/group parameter sizes based on a security level. 


\begin{DoxyParams}{Parameters}
{\em max\+P\+Len} & Maximum size of the field (modulus \char`\"{}p\char`\"{}) in bits. \\
\hline
{\em security\+Level} & Required security level in bits (at least 80) \\
\hline
{\em p\+Len} & Result\+: length of \char`\"{}p\char`\"{} in bits \\
\hline
{\em q\+Len} & Result\+: length of \char`\"{}q\char`\"{} in bits \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the process fails\\
\hline
\end{DoxyExceptions}
Calculates the appropriate sizes of \char`\"{}p\char`\"{} and \char`\"{}q\char`\"{} for a prime-\/order subgroup of order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. The sizes are based on a \textquotesingle{}security\+Level\textquotesingle{} provided in symmetric-\/equivalent bits. Our choices slightly exceed the specs in F\+I\+PS 186-\/3\+:

security\+Level = 80\+: p\+Len = 1024, q\+Len = 256 security\+Level = 112\+: p\+Len = 2048, q\+Len = 256 security\+Level = 128\+: q\+Len = 3072, q\+Len = 320

If the length of \char`\"{}p\char`\"{} exceeds the length provided in \char`\"{}max\+P\+Len\char`\"{}, or if \char`\"{}security\+Level $<$ 80\char`\"{} this routine throws an exception. \mbox{\Hypertarget{_param_generation_8cpp_file_a8d4a084866f5f0598e39704cedb96959}\label{_param_generation_8cpp_file_a8d4a084866f5f0598e39704cedb96959}} 
\index{Param\+Generation.\+h@{Param\+Generation.\+h}!derive\+Integer\+Group\+From\+Order@{derive\+Integer\+Group\+From\+Order}}
\index{derive\+Integer\+Group\+From\+Order@{derive\+Integer\+Group\+From\+Order}!Param\+Generation.\+h@{Param\+Generation.\+h}}
\subsubsection{\texorpdfstring{derive\+Integer\+Group\+From\+Order()}{deriveIntegerGroupFromOrder()}}
{\footnotesize\ttfamily Integer\+Group\+Params libzerocoin\+::derive\+Integer\+Group\+From\+Order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \&}]{group\+Order }\end{DoxyParamCaption})}



Deterministically compute a set of group parameters with a specified order. 


\begin{DoxyParams}{Parameters}
{\em group\+Order} & The order of the group \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An Integer\+Group\+Params object
\end{DoxyReturn}
Given \char`\"{}q\char`\"{} calculates the description of a group G of prime order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. \mbox{\Hypertarget{_param_generation_8cpp_file_a104c1a4d313174893b0de7595bfa7baa}\label{_param_generation_8cpp_file_a104c1a4d313174893b0de7595bfa7baa}} 
\index{Param\+Generation.\+h@{Param\+Generation.\+h}!derive\+Integer\+Group\+Params@{derive\+Integer\+Group\+Params}}
\index{derive\+Integer\+Group\+Params@{derive\+Integer\+Group\+Params}!Param\+Generation.\+h@{Param\+Generation.\+h}}
\subsubsection{\texorpdfstring{derive\+Integer\+Group\+Params()}{deriveIntegerGroupParams()}}
{\footnotesize\ttfamily Integer\+Group\+Params libzerocoin\+::derive\+Integer\+Group\+Params (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{seed,  }\item[{uint32\+\_\+t}]{p\+Len,  }\item[{uint32\+\_\+t}]{q\+Len }\end{DoxyParamCaption})}



Deterministically compute a set of group parameters using N\+I\+ST procedures. 


\begin{DoxyParams}{Parameters}
{\em seed\+Str} & A byte string seeding the process. \\
\hline
{\em p\+Len} & The desired length of the modulus \char`\"{}p\char`\"{} in bits \\
\hline
{\em q\+Len} & The desired length of the order \char`\"{}q\char`\"{} in bits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An Integer\+Group\+Params object
\end{DoxyReturn}
Calculates the description of a group G of prime order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. The input to this routine is in arbitrary seed. It uses the algorithms described in F\+I\+PS 186-\/3 Appendix A.\+1.\+2 to calculate primes \char`\"{}p\char`\"{} and \char`\"{}q\char`\"{}. It uses the procedure in Appendix A.\+2.\+3 to derive two generators \char`\"{}g\char`\"{}, \char`\"{}h\char`\"{}. \mbox{\Hypertarget{_param_generation_8cpp_file_a2099b8bbbed1501554a9be21e74b9254}\label{_param_generation_8cpp_file_a2099b8bbbed1501554a9be21e74b9254}} 
\index{Param\+Generation.\+h@{Param\+Generation.\+h}!generate\+Random\+Prime@{generate\+Random\+Prime}}
\index{generate\+Random\+Prime@{generate\+Random\+Prime}!Param\+Generation.\+h@{Param\+Generation.\+h}}
\subsubsection{\texorpdfstring{generate\+Random\+Prime()}{generateRandomPrime()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} libzerocoin\+::generate\+Random\+Prime (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{prime\+Bit\+Len,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{in\+\_\+seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}} $\ast$}]{out\+\_\+seed,  }\item[{uint32\+\_\+t $\ast$}]{prime\+\_\+gen\+\_\+counter }\end{DoxyParamCaption})}



Deterministically compute a random prime number. 


\begin{DoxyParams}{Parameters}
{\em prime\+Bit\+Len} & Desired bit length of the prime. \\
\hline
{\em in\+\_\+seed} & Input seed for the process. \\
\hline
{\em out\+\_\+seed} & Result\+: output seed from the process. \\
\hline
{\em prime\+\_\+gen\+\_\+counter} & Result\+: number of iterations required. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The resulting prime number. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em A} & std\+::runtime\+\_\+error if error.\\
\hline
\end{DoxyExceptions}
Generates a random prime number of prime\+Bit\+Len bits from a given input seed. Uses the Shawe-\/\+Taylor algorithm as described in F\+I\+PS 186-\/3 Appendix C.\+6. This is a recursive function. \mbox{\Hypertarget{_param_generation_8cpp_file_aeda115c7208be9405f951779ec131494}\label{_param_generation_8cpp_file_aeda115c7208be9405f951779ec131494}} 
\index{Param\+Generation.\+h@{Param\+Generation.\+h}!primality\+Test\+By\+Trial\+Division@{primality\+Test\+By\+Trial\+Division}}
\index{primality\+Test\+By\+Trial\+Division@{primality\+Test\+By\+Trial\+Division}!Param\+Generation.\+h@{Param\+Generation.\+h}}
\subsubsection{\texorpdfstring{primality\+Test\+By\+Trial\+Division()}{primalityTestByTrialDivision()}}
{\footnotesize\ttfamily bool libzerocoin\+::primality\+Test\+By\+Trial\+Division (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{candidate }\end{DoxyParamCaption})}



Determines whether a uint32\+\_\+t is a prime through trial division. 


\begin{DoxyParams}{Parameters}
{\em candidate} & Candidate to test. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the value is prime, false otherwise
\end{DoxyReturn}
Performs trial division to determine whether a uint32\+\_\+t is prime. 