\hypertarget{classarith__uint256}{}\section{arith\+\_\+uint256 Class Reference}
\label{classarith__uint256}\index{arith\+\_\+uint256@{arith\+\_\+uint256}}


{\ttfamily \#include $<$arith\+\_\+uint256.\+h$>$}

Inheritance diagram for arith\+\_\+uint256\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classarith__uint256}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classarith__uint256_a86c126d261e0edeea49e051e2f3b98a7}\label{classarith__uint256_a86c126d261e0edeea49e051e2f3b98a7}} 
{\bfseries arith\+\_\+uint256} (const \mbox{\hyperlink{classbase__uint}{base\+\_\+uint}}$<$ 256 $>$ \&b)
\item 
\mbox{\Hypertarget{classarith__uint256_a865adeb2767f24e0efc3abfb3d75170b}\label{classarith__uint256_a865adeb2767f24e0efc3abfb3d75170b}} 
{\bfseries arith\+\_\+uint256} (uint64\+\_\+t b)
\item 
\mbox{\Hypertarget{classarith__uint256_a0e8b76f74ffb7a251b15aff89b087fbf}\label{classarith__uint256_a0e8b76f74ffb7a251b15aff89b087fbf}} 
{\bfseries arith\+\_\+uint256} (const std\+::string \&str)
\item 
\mbox{\Hypertarget{classarith__uint256_ae0bf2417eed7eda2cdf67b0779bc3340}\label{classarith__uint256_ae0bf2417eed7eda2cdf67b0779bc3340}} 
{\bfseries arith\+\_\+uint256} (const std\+::vector$<$ unsigned char $>$ \&vch)
\item 
\mbox{\hyperlink{classarith__uint256}{arith\+\_\+uint256}} \& \mbox{\hyperlink{classarith__uint256_a458133c9f123519646b07e6143f2164f}{Set\+Compact}} (uint32\+\_\+t n\+Compact, bool $\ast$pf\+Negative=N\+U\+LL, bool $\ast$pf\+Overflow=N\+U\+LL)
\item 
\mbox{\Hypertarget{classarith__uint256_a0eeee9d8f29143ddf1bff2b1ffa8fdc1}\label{classarith__uint256_a0eeee9d8f29143ddf1bff2b1ffa8fdc1}} 
uint32\+\_\+t {\bfseries Get\+Compact} (bool f\+Negative=false) const
\item 
\mbox{\Hypertarget{classarith__uint256_a2e18ce8980d2076c1fec89aff80ef497}\label{classarith__uint256_a2e18ce8980d2076c1fec89aff80ef497}} 
uint64\+\_\+t {\bfseries Get\+Hash} (const \mbox{\hyperlink{classarith__uint256}{arith\+\_\+uint256}} \&salt) const
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classarith__uint256_aef075fd8d1a7e5937e9775b8e82c8a1b}\label{classarith__uint256_aef075fd8d1a7e5937e9775b8e82c8a1b}} 
\mbox{\hyperlink{classuint256}{uint256}} {\bfseries Arith\+To\+Uint256} (const \mbox{\hyperlink{classarith__uint256}{arith\+\_\+uint256}} \&)
\item 
\mbox{\Hypertarget{classarith__uint256_a9c9f84c20851f10a8ca5082bec97666a}\label{classarith__uint256_a9c9f84c20851f10a8ca5082bec97666a}} 
\mbox{\hyperlink{classarith__uint256}{arith\+\_\+uint256}} {\bfseries Uint\+To\+Arith256} (const \mbox{\hyperlink{classuint256}{uint256}} \&)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
256-\/bit unsigned big integer. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classarith__uint256_a458133c9f123519646b07e6143f2164f}\label{classarith__uint256_a458133c9f123519646b07e6143f2164f}} 
\index{arith\+\_\+uint256@{arith\+\_\+uint256}!Set\+Compact@{Set\+Compact}}
\index{Set\+Compact@{Set\+Compact}!arith\+\_\+uint256@{arith\+\_\+uint256}}
\subsubsection{\texorpdfstring{Set\+Compact()}{SetCompact()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classarith__uint256}{arith\+\_\+uint256}} \& arith\+\_\+uint256\+::\+Set\+Compact (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{n\+Compact,  }\item[{bool $\ast$}]{pf\+Negative = {\ttfamily NULL},  }\item[{bool $\ast$}]{pf\+Overflow = {\ttfamily NULL} }\end{DoxyParamCaption})}

The \char`\"{}compact\char`\"{} format is a representation of a whole number N using an unsigned 32bit number similar to a floating point format. The most significant 8 bits are the unsigned exponent of base 256. This exponent can be thought of as \char`\"{}number of bytes of N\char`\"{}. The lower 23 bits are the mantissa. Bit number 24 (0x800000) represents the sign of N. N = (-\/1$^\wedge$sign) $\ast$ mantissa $\ast$ 256$^\wedge$(exponent-\/3)

Satoshi\textquotesingle{}s original implementation used B\+N\+\_\+bn2mpi() and B\+N\+\_\+mpi2bn(). M\+PI uses the most significant bit of the first byte as sign. Thus 0x1234560000 is compact (0x05123456) and 0xc0de000000 is compact (0x0600c0de)

Bitcoin only uses this \char`\"{}compact\char`\"{} format for encoding difficulty targets, which are unsigned 256bit quantities. Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
P\+I\+V\+X/src/arith\+\_\+uint256.\+h\item 
P\+I\+V\+X/src/arith\+\_\+uint256.\+cpp\end{DoxyCompactItemize}
