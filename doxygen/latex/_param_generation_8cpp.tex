\hypertarget{_param_generation_8cpp}{}\section{P\+I\+V\+X/src/libzerocoin/\+Param\+Generation.cpp File Reference}
\label{_param_generation_8cpp}\index{P\+I\+V\+X/src/libzerocoin/\+Param\+Generation.\+cpp@{P\+I\+V\+X/src/libzerocoin/\+Param\+Generation.\+cpp}}


Parameter manipulation routines for the Zerocoin cryptographic components.  


{\ttfamily \#include \char`\"{}Param\+Generation.\+h\char`\"{}}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include \char`\"{}hash.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}uint256.\+h\char`\"{}}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{_param_generation_8cpp_a6304d284cf7c81d9598ea68f3c5a81df}{libzerocoin\+::\+Calculate\+Params}} (Zerocoin\+Params \&params, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} N, string aux, uint32\+\_\+t security\+Level)
\begin{DoxyCompactList}\small\item\em Fill in a set of Zerocoin parameters from a modulus \char`\"{}\+N\char`\"{}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classuint256}{uint256}} \mbox{\hyperlink{_param_generation_8cpp_a49d954a2ad7e4abe50ae454c900d915a}{libzerocoin\+::calculate\+Generator\+Seed}} (\mbox{\hyperlink{classuint256}{uint256}} seed, \mbox{\hyperlink{classuint256}{uint256}} p\+Seed, \mbox{\hyperlink{classuint256}{uint256}} q\+Seed, string label, uint32\+\_\+t index, uint32\+\_\+t count)
\begin{DoxyCompactList}\small\item\em Format a seed string by hashing several values. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classuint256}{uint256}} \mbox{\hyperlink{_param_generation_8cpp_af8b666ac58e459ab2faad6df2d001b6c}{libzerocoin\+::calculate\+Seed}} (\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} modulus, string aux\+String, uint32\+\_\+t security\+Level, string group\+Name)
\begin{DoxyCompactList}\small\item\em Format a seed string by hashing several values. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{_param_generation_8cpp_a2ab9735f14a3fdcdf18e0fd410a6e701}\label{_param_generation_8cpp_a2ab9735f14a3fdcdf18e0fd410a6e701}} 
\mbox{\hyperlink{classuint256}{uint256}} {\bfseries libzerocoin\+::calculate\+Hash} (\mbox{\hyperlink{classuint256}{uint256}} input)
\item 
void \mbox{\hyperlink{_param_generation_8cpp_af84d8d406285f665c4e8c60443a57c97}{libzerocoin\+::calculate\+Group\+Param\+Lengths}} (uint32\+\_\+t max\+P\+Len, uint32\+\_\+t security\+Level, uint32\+\_\+t $\ast$p\+Len, uint32\+\_\+t $\ast$q\+Len)
\begin{DoxyCompactList}\small\item\em Calculate field/group parameter sizes based on a security level. \end{DoxyCompactList}\item 
Integer\+Group\+Params \mbox{\hyperlink{_param_generation_8cpp_a104c1a4d313174893b0de7595bfa7baa}{libzerocoin\+::derive\+Integer\+Group\+Params}} (\mbox{\hyperlink{classuint256}{uint256}} seed, uint32\+\_\+t p\+Len, uint32\+\_\+t q\+Len)
\begin{DoxyCompactList}\small\item\em Deterministically compute a set of group parameters using N\+I\+ST procedures. \end{DoxyCompactList}\item 
Integer\+Group\+Params \mbox{\hyperlink{_param_generation_8cpp_a8d4a084866f5f0598e39704cedb96959}{libzerocoin\+::derive\+Integer\+Group\+From\+Order}} (\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \&group\+Order)
\begin{DoxyCompactList}\small\item\em Deterministically compute a set of group parameters with a specified order. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_param_generation_8cpp_ae993b839bf47f3e64151b39abd3a5c08}{libzerocoin\+::calculate\+Group\+Modulus\+And\+Order}} (\mbox{\hyperlink{classuint256}{uint256}} seed, uint32\+\_\+t p\+Len, uint32\+\_\+t q\+Len, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$result\+Modulus, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$result\+Group\+Order, \mbox{\hyperlink{classuint256}{uint256}} $\ast$result\+Pseed, \mbox{\hyperlink{classuint256}{uint256}} $\ast$result\+Qseed)
\begin{DoxyCompactList}\small\item\em Deterministically compute a group description using N\+I\+ST procedures. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \mbox{\hyperlink{_param_generation_8cpp_a99d5082673d5c4e4d0f629f986636946}{libzerocoin\+::calculate\+Group\+Generator}} (\mbox{\hyperlink{classuint256}{uint256}} seed, \mbox{\hyperlink{classuint256}{uint256}} p\+Seed, \mbox{\hyperlink{classuint256}{uint256}} q\+Seed, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} modulus, \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} group\+Order, uint32\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Deterministically compute a generator for a given group. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \mbox{\hyperlink{_param_generation_8cpp_a2099b8bbbed1501554a9be21e74b9254}{libzerocoin\+::generate\+Random\+Prime}} (uint32\+\_\+t prime\+Bit\+Len, \mbox{\hyperlink{classuint256}{uint256}} in\+\_\+seed, \mbox{\hyperlink{classuint256}{uint256}} $\ast$out\+\_\+seed, uint32\+\_\+t $\ast$prime\+\_\+gen\+\_\+counter)
\begin{DoxyCompactList}\small\item\em Deterministically compute a random prime number. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{_param_generation_8cpp_a6f07f95c6873008f19659311147e7a41}\label{_param_generation_8cpp_a6f07f95c6873008f19659311147e7a41}} 
\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} {\bfseries libzerocoin\+::generate\+Integer\+From\+Seed} (uint32\+\_\+t num\+Bits, \mbox{\hyperlink{classuint256}{uint256}} seed, uint32\+\_\+t $\ast$num\+Iterations)
\item 
bool \mbox{\hyperlink{_param_generation_8cpp_aeda115c7208be9405f951779ec131494}{libzerocoin\+::primality\+Test\+By\+Trial\+Division}} (uint32\+\_\+t candidate)
\begin{DoxyCompactList}\small\item\em Determines whether a uint32\+\_\+t is a prime through trial division. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Parameter manipulation routines for the Zerocoin cryptographic components. 

\begin{DoxyAuthor}{Author}
Ian Miers, Christina Garman and Matthew Green 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
June 2013
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright 2013 Ian Miers, Christina Garman and Matthew Green  This project is released under the M\+IT license. 
\end{DoxyCopyright}


\subsection{Function Documentation}
\mbox{\Hypertarget{_param_generation_8cpp_file_a49d954a2ad7e4abe50ae454c900d915a}\label{_param_generation_8cpp_file_a49d954a2ad7e4abe50ae454c900d915a}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!calculate\+Generator\+Seed@{calculate\+Generator\+Seed}}
\index{calculate\+Generator\+Seed@{calculate\+Generator\+Seed}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{calculate\+Generator\+Seed()}{calculateGeneratorSeed()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classuint256}{uint256}} libzerocoin\+::calculate\+Generator\+Seed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{p\+Seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{q\+Seed,  }\item[{string}]{label,  }\item[{uint32\+\_\+t}]{index,  }\item[{uint32\+\_\+t}]{count }\end{DoxyParamCaption})}



Format a seed string by hashing several values. 


\begin{DoxyParams}{Parameters}
{\em N} & A \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \\
\hline
{\em aux} & An auxiliary string \\
\hline
{\em security\+Level} & The security level in bits \\
\hline
{\em group\+Name} & A group description string \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the process fails\\
\hline
\end{DoxyExceptions}
Returns the hash of the value. \mbox{\Hypertarget{_param_generation_8cpp_file_a99d5082673d5c4e4d0f629f986636946}\label{_param_generation_8cpp_file_a99d5082673d5c4e4d0f629f986636946}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!calculate\+Group\+Generator@{calculate\+Group\+Generator}}
\index{calculate\+Group\+Generator@{calculate\+Group\+Generator}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{calculate\+Group\+Generator()}{calculateGroupGenerator()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} libzerocoin\+::calculate\+Group\+Generator (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{p\+Seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{q\+Seed,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}}}]{modulus,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}}}]{group\+Order,  }\item[{uint32\+\_\+t}]{index }\end{DoxyParamCaption})}



Deterministically compute a generator for a given group. 


\begin{DoxyParams}{Parameters}
{\em seed} & A first seed for the process. \\
\hline
{\em p\+Seed} & A second seed for the process. \\
\hline
{\em q\+Seed} & A third seed for the process. \\
\hline
{\em modulus} & Proposed prime modulus for the field. \\
\hline
{\em group\+Order} & Proposed order of the group. \\
\hline
{\em index} & Index value, selects which generator you\textquotesingle{}re building. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The resulting generator. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em A} & std\+::runtime\+\_\+error if error.\\
\hline
\end{DoxyExceptions}
Generates a random group generator deterministically as a function of (seed,p\+Seed,q\+Seed) Uses the algorithm described in F\+I\+PS 186-\/3 Appendix A.\+2.\+3. \mbox{\Hypertarget{_param_generation_8cpp_file_ae993b839bf47f3e64151b39abd3a5c08}\label{_param_generation_8cpp_file_ae993b839bf47f3e64151b39abd3a5c08}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!calculate\+Group\+Modulus\+And\+Order@{calculate\+Group\+Modulus\+And\+Order}}
\index{calculate\+Group\+Modulus\+And\+Order@{calculate\+Group\+Modulus\+And\+Order}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{calculate\+Group\+Modulus\+And\+Order()}{calculateGroupModulusAndOrder()}}
{\footnotesize\ttfamily void libzerocoin\+::calculate\+Group\+Modulus\+And\+Order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{seed,  }\item[{uint32\+\_\+t}]{p\+Len,  }\item[{uint32\+\_\+t}]{q\+Len,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$}]{result\+Modulus,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} $\ast$}]{result\+Group\+Order,  }\item[{\mbox{\hyperlink{classuint256}{uint256}} $\ast$}]{result\+Pseed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}} $\ast$}]{result\+Qseed }\end{DoxyParamCaption})}



Deterministically compute a group description using N\+I\+ST procedures. 


\begin{DoxyParams}{Parameters}
{\em seed} & A byte string seeding the process. \\
\hline
{\em p\+Len} & The desired length of the modulus \char`\"{}p\char`\"{} in bits \\
\hline
{\em q\+Len} & The desired length of the order \char`\"{}q\char`\"{} in bits \\
\hline
{\em result\+Modulus} & A value \char`\"{}p\char`\"{} describing a finite field \char`\"{}\+F\+\_\+p\char`\"{} \\
\hline
{\em result\+Group\+Order} & A value \char`\"{}q\char`\"{} describing the order of a subgroup \\
\hline
{\em result\+Domain\+Parameter\+Seed} & A resulting seed for use in later calculations.\\
\hline
\end{DoxyParams}
Calculates the description of a group G of prime order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. The input to this routine is in arbitrary seed. It uses the algorithms described in F\+I\+PS 186-\/3 Appendix A.\+1.\+2 to calculate primes \char`\"{}p\char`\"{} and \char`\"{}q\char`\"{}. \mbox{\Hypertarget{_param_generation_8cpp_file_af84d8d406285f665c4e8c60443a57c97}\label{_param_generation_8cpp_file_af84d8d406285f665c4e8c60443a57c97}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!calculate\+Group\+Param\+Lengths@{calculate\+Group\+Param\+Lengths}}
\index{calculate\+Group\+Param\+Lengths@{calculate\+Group\+Param\+Lengths}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{calculate\+Group\+Param\+Lengths()}{calculateGroupParamLengths()}}
{\footnotesize\ttfamily void libzerocoin\+::calculate\+Group\+Param\+Lengths (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{max\+P\+Len,  }\item[{uint32\+\_\+t}]{security\+Level,  }\item[{uint32\+\_\+t $\ast$}]{p\+Len,  }\item[{uint32\+\_\+t $\ast$}]{q\+Len }\end{DoxyParamCaption})}



Calculate field/group parameter sizes based on a security level. 


\begin{DoxyParams}{Parameters}
{\em max\+P\+Len} & Maximum size of the field (modulus \char`\"{}p\char`\"{}) in bits. \\
\hline
{\em security\+Level} & Required security level in bits (at least 80) \\
\hline
{\em p\+Len} & Result\+: length of \char`\"{}p\char`\"{} in bits \\
\hline
{\em q\+Len} & Result\+: length of \char`\"{}q\char`\"{} in bits \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the process fails\\
\hline
\end{DoxyExceptions}
Calculates the appropriate sizes of \char`\"{}p\char`\"{} and \char`\"{}q\char`\"{} for a prime-\/order subgroup of order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. The sizes are based on a \textquotesingle{}security\+Level\textquotesingle{} provided in symmetric-\/equivalent bits. Our choices slightly exceed the specs in F\+I\+PS 186-\/3\+:

security\+Level = 80\+: p\+Len = 1024, q\+Len = 256 security\+Level = 112\+: p\+Len = 2048, q\+Len = 256 security\+Level = 128\+: q\+Len = 3072, q\+Len = 320

If the length of \char`\"{}p\char`\"{} exceeds the length provided in \char`\"{}max\+P\+Len\char`\"{}, or if \char`\"{}security\+Level $<$ 80\char`\"{} this routine throws an exception. \mbox{\Hypertarget{_param_generation_8cpp_file_a6304d284cf7c81d9598ea68f3c5a81df}\label{_param_generation_8cpp_file_a6304d284cf7c81d9598ea68f3c5a81df}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!Calculate\+Params@{Calculate\+Params}}
\index{Calculate\+Params@{Calculate\+Params}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{Calculate\+Params()}{CalculateParams()}}
{\footnotesize\ttfamily void libzerocoin\+::\+Calculate\+Params (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classlibzerocoin_1_1_zerocoin_params}{Zerocoin\+Params}} \&}]{params,  }\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}}}]{N,  }\item[{string}]{aux,  }\item[{uint32\+\_\+t}]{security\+Level }\end{DoxyParamCaption})}



Fill in a set of Zerocoin parameters from a modulus \char`\"{}\+N\char`\"{}. 


\begin{DoxyParams}{Parameters}
{\em N} & A trusted R\+SA modulus \\
\hline
{\em aux} & An optional auxiliary string used in derivation \\
\hline
{\em security\+Level} & A security level\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the process fails\\
\hline
\end{DoxyExceptions}
Fills in a Z\+C\+\_\+\+Params data structure deterministically from a trustworthy R\+SA modulus \char`\"{}\+N\char`\"{}, which is provided as a \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}}.

Note\+: this routine makes the fundamental assumption that \char`\"{}\+N\char`\"{} encodes a valid R\+S\+A-\/style modulus of the form \char`\"{}e1$\ast$e2\char`\"{} for some unknown safe primes \char`\"{}e1\char`\"{} and \char`\"{}e2\char`\"{}. These factors must not be known to any party, or the security of Zerocoin is compromised. The integer \char`\"{}\+N\char`\"{} must be a M\+I\+N\+I\+M\+UM of 1023 in length, and 3072 bits is strongly recommended. \mbox{\Hypertarget{_param_generation_8cpp_file_af8b666ac58e459ab2faad6df2d001b6c}\label{_param_generation_8cpp_file_af8b666ac58e459ab2faad6df2d001b6c}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!calculate\+Seed@{calculate\+Seed}}
\index{calculate\+Seed@{calculate\+Seed}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{calculate\+Seed()}{calculateSeed()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classuint256}{uint256}} libzerocoin\+::calculate\+Seed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}}}]{modulus,  }\item[{string}]{aux\+String,  }\item[{uint32\+\_\+t}]{security\+Level,  }\item[{string}]{group\+Name }\end{DoxyParamCaption})}



Format a seed string by hashing several values. 


\begin{DoxyParams}{Parameters}
{\em N} & A \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \\
\hline
{\em aux} & An auxiliary string \\
\hline
{\em security\+Level} & The security level in bits \\
\hline
{\em group\+Name} & A group description string \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the process fails\\
\hline
\end{DoxyExceptions}
Returns the hash of the value. \mbox{\Hypertarget{_param_generation_8cpp_file_a8d4a084866f5f0598e39704cedb96959}\label{_param_generation_8cpp_file_a8d4a084866f5f0598e39704cedb96959}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!derive\+Integer\+Group\+From\+Order@{derive\+Integer\+Group\+From\+Order}}
\index{derive\+Integer\+Group\+From\+Order@{derive\+Integer\+Group\+From\+Order}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{derive\+Integer\+Group\+From\+Order()}{deriveIntegerGroupFromOrder()}}
{\footnotesize\ttfamily Integer\+Group\+Params libzerocoin\+::derive\+Integer\+Group\+From\+Order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} \&}]{group\+Order }\end{DoxyParamCaption})}



Deterministically compute a set of group parameters with a specified order. 


\begin{DoxyParams}{Parameters}
{\em group\+Order} & The order of the group \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An Integer\+Group\+Params object
\end{DoxyReturn}
Given \char`\"{}q\char`\"{} calculates the description of a group G of prime order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. \mbox{\Hypertarget{_param_generation_8cpp_file_a104c1a4d313174893b0de7595bfa7baa}\label{_param_generation_8cpp_file_a104c1a4d313174893b0de7595bfa7baa}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!derive\+Integer\+Group\+Params@{derive\+Integer\+Group\+Params}}
\index{derive\+Integer\+Group\+Params@{derive\+Integer\+Group\+Params}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{derive\+Integer\+Group\+Params()}{deriveIntegerGroupParams()}}
{\footnotesize\ttfamily Integer\+Group\+Params libzerocoin\+::derive\+Integer\+Group\+Params (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{seed,  }\item[{uint32\+\_\+t}]{p\+Len,  }\item[{uint32\+\_\+t}]{q\+Len }\end{DoxyParamCaption})}



Deterministically compute a set of group parameters using N\+I\+ST procedures. 


\begin{DoxyParams}{Parameters}
{\em seed\+Str} & A byte string seeding the process. \\
\hline
{\em p\+Len} & The desired length of the modulus \char`\"{}p\char`\"{} in bits \\
\hline
{\em q\+Len} & The desired length of the order \char`\"{}q\char`\"{} in bits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An Integer\+Group\+Params object
\end{DoxyReturn}
Calculates the description of a group G of prime order \char`\"{}q\char`\"{} embedded within a field \char`\"{}\+F\+\_\+p\char`\"{}. The input to this routine is in arbitrary seed. It uses the algorithms described in F\+I\+PS 186-\/3 Appendix A.\+1.\+2 to calculate primes \char`\"{}p\char`\"{} and \char`\"{}q\char`\"{}. It uses the procedure in Appendix A.\+2.\+3 to derive two generators \char`\"{}g\char`\"{}, \char`\"{}h\char`\"{}. \mbox{\Hypertarget{_param_generation_8cpp_file_a2099b8bbbed1501554a9be21e74b9254}\label{_param_generation_8cpp_file_a2099b8bbbed1501554a9be21e74b9254}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!generate\+Random\+Prime@{generate\+Random\+Prime}}
\index{generate\+Random\+Prime@{generate\+Random\+Prime}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{generate\+Random\+Prime()}{generateRandomPrime()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_big_num}{C\+Big\+Num}} libzerocoin\+::generate\+Random\+Prime (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{prime\+Bit\+Len,  }\item[{\mbox{\hyperlink{classuint256}{uint256}}}]{in\+\_\+seed,  }\item[{\mbox{\hyperlink{classuint256}{uint256}} $\ast$}]{out\+\_\+seed,  }\item[{uint32\+\_\+t $\ast$}]{prime\+\_\+gen\+\_\+counter }\end{DoxyParamCaption})}



Deterministically compute a random prime number. 


\begin{DoxyParams}{Parameters}
{\em prime\+Bit\+Len} & Desired bit length of the prime. \\
\hline
{\em in\+\_\+seed} & Input seed for the process. \\
\hline
{\em out\+\_\+seed} & Result\+: output seed from the process. \\
\hline
{\em prime\+\_\+gen\+\_\+counter} & Result\+: number of iterations required. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The resulting prime number. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em A} & std\+::runtime\+\_\+error if error.\\
\hline
\end{DoxyExceptions}
Generates a random prime number of prime\+Bit\+Len bits from a given input seed. Uses the Shawe-\/\+Taylor algorithm as described in F\+I\+PS 186-\/3 Appendix C.\+6. This is a recursive function. \mbox{\Hypertarget{_param_generation_8cpp_file_aeda115c7208be9405f951779ec131494}\label{_param_generation_8cpp_file_aeda115c7208be9405f951779ec131494}} 
\index{Param\+Generation.\+cpp@{Param\+Generation.\+cpp}!primality\+Test\+By\+Trial\+Division@{primality\+Test\+By\+Trial\+Division}}
\index{primality\+Test\+By\+Trial\+Division@{primality\+Test\+By\+Trial\+Division}!Param\+Generation.\+cpp@{Param\+Generation.\+cpp}}
\subsubsection{\texorpdfstring{primality\+Test\+By\+Trial\+Division()}{primalityTestByTrialDivision()}}
{\footnotesize\ttfamily bool libzerocoin\+::primality\+Test\+By\+Trial\+Division (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{candidate }\end{DoxyParamCaption})}



Determines whether a uint32\+\_\+t is a prime through trial division. 


\begin{DoxyParams}{Parameters}
{\em candidate} & Candidate to test. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the value is prime, false otherwise
\end{DoxyReturn}
Performs trial division to determine whether a uint32\+\_\+t is prime. 