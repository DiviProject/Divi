\hypertarget{class_c_key}{}\section{C\+Key Class Reference}
\label{class_c_key}\index{C\+Key@{C\+Key}}


{\ttfamily \#include $<$key.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_key_a8f4ca910c7b7e729a3f2a5c59d060d3d}\label{class_c_key_a8f4ca910c7b7e729a3f2a5c59d060d3d}} 
\mbox{\hyperlink{class_c_key_a8f4ca910c7b7e729a3f2a5c59d060d3d}{C\+Key}} ()
\begin{DoxyCompactList}\small\item\em Construct an invalid private key. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_afcea34cefd25675f4cf9b03eaa4bb7d9}\label{class_c_key_afcea34cefd25675f4cf9b03eaa4bb7d9}} 
\mbox{\hyperlink{class_c_key_afcea34cefd25675f4cf9b03eaa4bb7d9}{C\+Key}} (const \mbox{\hyperlink{class_c_key}{C\+Key}} \&secret)
\begin{DoxyCompactList}\small\item\em Copy constructor. This is necessary because of memlocking. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_a57d5b254748cef054c40f99c1c339147}\label{class_c_key_a57d5b254748cef054c40f99c1c339147}} 
\mbox{\hyperlink{class_c_key_a57d5b254748cef054c40f99c1c339147}{$\sim$\+C\+Key}} ()
\begin{DoxyCompactList}\small\item\em Destructor (again necessary because of memlocking). \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_aaa13d5f08456bba094210c5eeabf64c8}\label{class_c_key_aaa13d5f08456bba094210c5eeabf64c8}} 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_c_key_aaa13d5f08456bba094210c5eeabf64c8}{Set}} (const T pbegin, const T pend, bool f\+Compressed\+In)
\begin{DoxyCompactList}\small\item\em Initialize using begin and end iterators to byte data. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_a468a9a8cd148ab4a43e7d76bbdc78abe}\label{class_c_key_a468a9a8cd148ab4a43e7d76bbdc78abe}} 
unsigned int \mbox{\hyperlink{class_c_key_a468a9a8cd148ab4a43e7d76bbdc78abe}{size}} () const
\begin{DoxyCompactList}\small\item\em Simple read-\/only vector-\/like interface. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_ab8dee0ad9d933304a22284ee40040847}\label{class_c_key_ab8dee0ad9d933304a22284ee40040847}} 
const unsigned char $\ast$ {\bfseries begin} () const
\item 
\mbox{\Hypertarget{class_c_key_a41c700c4a732672e4b7cc60d811dbf41}\label{class_c_key_a41c700c4a732672e4b7cc60d811dbf41}} 
const unsigned char $\ast$ {\bfseries end} () const
\item 
\mbox{\Hypertarget{class_c_key_a56e06c48d504a1a65e244e5fc35cdecc}\label{class_c_key_a56e06c48d504a1a65e244e5fc35cdecc}} 
bool \mbox{\hyperlink{class_c_key_a56e06c48d504a1a65e244e5fc35cdecc}{Is\+Valid}} () const
\begin{DoxyCompactList}\small\item\em Check whether this private key is valid. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_a96b017433a65335775cf3807d73f85ce}\label{class_c_key_a96b017433a65335775cf3807d73f85ce}} 
bool \mbox{\hyperlink{class_c_key_a96b017433a65335775cf3807d73f85ce}{Is\+Compressed}} () const
\begin{DoxyCompactList}\small\item\em Check whether the public key corresponding to this private key is (to be) compressed. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_aa62c082c9037565fce02b457cc335e7b}\label{class_c_key_aa62c082c9037565fce02b457cc335e7b}} 
bool \mbox{\hyperlink{class_c_key_aa62c082c9037565fce02b457cc335e7b}{Set\+Priv\+Key}} (const C\+Priv\+Key \&vch\+Priv\+Key, bool f\+Compressed)
\begin{DoxyCompactList}\small\item\em Initialize from a C\+Priv\+Key (serialized Open\+S\+SL private key data). \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_a9d12ed9d297e4286250fd7ea6b59e1a5}\label{class_c_key_a9d12ed9d297e4286250fd7ea6b59e1a5}} 
void \mbox{\hyperlink{class_c_key_a9d12ed9d297e4286250fd7ea6b59e1a5}{Make\+New\+Key}} (bool f\+Compressed)
\begin{DoxyCompactList}\small\item\em Generate a new private key using a cryptographic P\+R\+NG. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_key_a2984be4b20b4873c440e846d8e5594e0}\label{class_c_key_a2984be4b20b4873c440e846d8e5594e0}} 
\mbox{\hyperlink{classuint256}{uint256}} {\bfseries Get\+Priv\+Key\+\_\+256} ()
\item 
C\+Priv\+Key \mbox{\hyperlink{class_c_key_a91b6ecf71cc16e0b05ce79ec9276e729}{Get\+Priv\+Key}} () const
\item 
\mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \mbox{\hyperlink{class_c_key_aa1085c59603a62db6ec776300f250337}{Get\+Pub\+Key}} () const
\item 
bool \mbox{\hyperlink{class_c_key_aa9b184a4a71d3e1a40aab360cf68e86c}{Sign}} (const \mbox{\hyperlink{classuint256}{uint256}} \&hash, std\+::vector$<$ unsigned char $>$ \&vch\+Sig, uint32\+\_\+t test\+\_\+case=0) const
\item 
bool \mbox{\hyperlink{class_c_key_afe77d80889aa68e92e6882e75424cfb8}{Sign\+Compact}} (const \mbox{\hyperlink{classuint256}{uint256}} \&hash, std\+::vector$<$ unsigned char $>$ \&vch\+Sig) const
\item 
\mbox{\Hypertarget{class_c_key_a5166e6f49c17c3ad47ac0fa89305307b}\label{class_c_key_a5166e6f49c17c3ad47ac0fa89305307b}} 
bool \mbox{\hyperlink{class_c_key_a5166e6f49c17c3ad47ac0fa89305307b}{Derive}} (\mbox{\hyperlink{class_c_key}{C\+Key}} \&key\+Child, unsigned char cc\+Child\mbox{[}32\mbox{]}, unsigned int n\+Child, const unsigned char cc\mbox{[}32\mbox{]}) const
\begin{DoxyCompactList}\small\item\em Derive B\+I\+P32 child key. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_c_key_ac53425b8d0f89067bce781c485101b20}{Verify\+Pub\+Key}} (const \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \&vch\+Pub\+Key) const
\item 
\mbox{\Hypertarget{class_c_key_a141751588f8bfe5f1b6fc27f4e64b63f}\label{class_c_key_a141751588f8bfe5f1b6fc27f4e64b63f}} 
bool \mbox{\hyperlink{class_c_key_a141751588f8bfe5f1b6fc27f4e64b63f}{Load}} (C\+Priv\+Key \&privkey, \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \&vch\+Pub\+Key, bool f\+Skip\+Check)
\begin{DoxyCompactList}\small\item\em Load private key and check that public key matches. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_key_a625c363d9adfbd4dda22f3a67a898cf4}\label{class_c_key_a625c363d9adfbd4dda22f3a67a898cf4}} 
static bool \mbox{\hyperlink{class_c_key_a625c363d9adfbd4dda22f3a67a898cf4}{Check\+Signature\+Element}} (const unsigned char $\ast$vch, int len, bool half)
\begin{DoxyCompactList}\small\item\em Check whether an element of a signature (r or s) is valid. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_key_a381efd9184dc467e73e690329c70371d}\label{class_c_key_a381efd9184dc467e73e690329c70371d}} 
bool {\bfseries operator==} (const \mbox{\hyperlink{class_c_key}{C\+Key}} \&a, const \mbox{\hyperlink{class_c_key}{C\+Key}} \&b)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
An encapsulated private key. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_c_key_a91b6ecf71cc16e0b05ce79ec9276e729}\label{class_c_key_a91b6ecf71cc16e0b05ce79ec9276e729}} 
\index{C\+Key@{C\+Key}!Get\+Priv\+Key@{Get\+Priv\+Key}}
\index{Get\+Priv\+Key@{Get\+Priv\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Get\+Priv\+Key()}{GetPrivKey()}}
{\footnotesize\ttfamily C\+Priv\+Key C\+Key\+::\+Get\+Priv\+Key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Convert the private key to a C\+Priv\+Key (serialized Open\+S\+SL private key data). This is expensive. \mbox{\Hypertarget{class_c_key_aa1085c59603a62db6ec776300f250337}\label{class_c_key_aa1085c59603a62db6ec776300f250337}} 
\index{C\+Key@{C\+Key}!Get\+Pub\+Key@{Get\+Pub\+Key}}
\index{Get\+Pub\+Key@{Get\+Pub\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Get\+Pub\+Key()}{GetPubKey()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} C\+Key\+::\+Get\+Pub\+Key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Compute the public key from a private key. This is expensive. \mbox{\Hypertarget{class_c_key_aa9b184a4a71d3e1a40aab360cf68e86c}\label{class_c_key_aa9b184a4a71d3e1a40aab360cf68e86c}} 
\index{C\+Key@{C\+Key}!Sign@{Sign}}
\index{Sign@{Sign}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Sign()}{Sign()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Sign (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classuint256}{uint256}} \&}]{hash,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Sig,  }\item[{uint32\+\_\+t}]{test\+\_\+case = {\ttfamily 0} }\end{DoxyParamCaption}) const}

Create a D\+E\+R-\/serialized signature. The test\+\_\+case parameter tweaks the deterministic nonce, and is only for testing. It should be zero for normal use. \mbox{\Hypertarget{class_c_key_afe77d80889aa68e92e6882e75424cfb8}\label{class_c_key_afe77d80889aa68e92e6882e75424cfb8}} 
\index{C\+Key@{C\+Key}!Sign\+Compact@{Sign\+Compact}}
\index{Sign\+Compact@{Sign\+Compact}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Sign\+Compact()}{SignCompact()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Sign\+Compact (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classuint256}{uint256}} \&}]{hash,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Sig }\end{DoxyParamCaption}) const}

Create a compact signature (65 bytes), which allows reconstructing the used public key. The format is one header byte, followed by two times 32 bytes for the serialized r and s values. The header byte\+: 0x1B = first key with even y, 0x1C = first key with odd y, 0x1D = second key with even y, 0x1E = second key with odd y, add 0x04 for compressed keys. \mbox{\Hypertarget{class_c_key_ac53425b8d0f89067bce781c485101b20}\label{class_c_key_ac53425b8d0f89067bce781c485101b20}} 
\index{C\+Key@{C\+Key}!Verify\+Pub\+Key@{Verify\+Pub\+Key}}
\index{Verify\+Pub\+Key@{Verify\+Pub\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Verify\+Pub\+Key()}{VerifyPubKey()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Verify\+Pub\+Key (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \&}]{vch\+Pub\+Key }\end{DoxyParamCaption}) const}

Verify thoroughly whether a private key and a public key match. This is done using a different mechanism than just regenerating it. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
P\+I\+V\+X/src/key.\+h\item 
P\+I\+V\+X/src/key.\+cpp\end{DoxyCompactItemize}
