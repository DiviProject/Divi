\hypertarget{class_c_bloom_filter}{}\section{C\+Bloom\+Filter Class Reference}
\label{class_c_bloom_filter}\index{C\+Bloom\+Filter@{C\+Bloom\+Filter}}


{\ttfamily \#include $<$bloom.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_c_bloom_filter_a6395cfcb278ed9cf4ae873549c996f83}{C\+Bloom\+Filter}} (unsigned int n\+Elements, double n\+F\+P\+Rate, unsigned int n\+Tweak, unsigned char n\+Flags\+In)
\item 
\mbox{\Hypertarget{class_c_bloom_filter_a2d12234d7febc6197a7349d609733cca}\label{class_c_bloom_filter_a2d12234d7febc6197a7349d609733cca}} 
{\footnotesize template$<$typename Stream , typename Operation $>$ }\\void {\bfseries Serialization\+Op} (Stream \&s, Operation ser\+\_\+action, int n\+Type, int n\+Version)
\item 
\mbox{\Hypertarget{class_c_bloom_filter_abba52843c7c691ef7deb07d9a645dcc2}\label{class_c_bloom_filter_abba52843c7c691ef7deb07d9a645dcc2}} 
void {\bfseries insert} (const std\+::vector$<$ unsigned char $>$ \&v\+Key)
\item 
\mbox{\Hypertarget{class_c_bloom_filter_aa77e023fc94fd17a0532bf17906e2146}\label{class_c_bloom_filter_aa77e023fc94fd17a0532bf17906e2146}} 
void {\bfseries insert} (const \mbox{\hyperlink{class_c_out_point}{C\+Out\+Point}} \&outpoint)
\item 
\mbox{\Hypertarget{class_c_bloom_filter_ac86479ac4ac157a7f0188baaa93202cb}\label{class_c_bloom_filter_ac86479ac4ac157a7f0188baaa93202cb}} 
void {\bfseries insert} (const \mbox{\hyperlink{classuint256}{uint256}} \&hash)
\item 
\mbox{\Hypertarget{class_c_bloom_filter_afe62e10a4c4cf64e18a2a659d0bcc31b}\label{class_c_bloom_filter_afe62e10a4c4cf64e18a2a659d0bcc31b}} 
bool {\bfseries contains} (const std\+::vector$<$ unsigned char $>$ \&v\+Key) const
\item 
\mbox{\Hypertarget{class_c_bloom_filter_af4557c3253f218eaf13e6d7da53e20e9}\label{class_c_bloom_filter_af4557c3253f218eaf13e6d7da53e20e9}} 
bool {\bfseries contains} (const \mbox{\hyperlink{class_c_out_point}{C\+Out\+Point}} \&outpoint) const
\item 
\mbox{\Hypertarget{class_c_bloom_filter_a4c26810781cdc0fd34443f32612ac83b}\label{class_c_bloom_filter_a4c26810781cdc0fd34443f32612ac83b}} 
bool {\bfseries contains} (const \mbox{\hyperlink{classuint256}{uint256}} \&hash) const
\item 
\mbox{\Hypertarget{class_c_bloom_filter_abf30228c0b24c57530f6b6734cd40252}\label{class_c_bloom_filter_abf30228c0b24c57530f6b6734cd40252}} 
void {\bfseries clear} ()
\item 
bool \mbox{\hyperlink{class_c_bloom_filter_a06f2094da8e7d9c6ad4ea426858e32de}{Is\+Within\+Size\+Constraints}} () const
\item 
\mbox{\Hypertarget{class_c_bloom_filter_aec420a9b66ab133090c2b4b8ed286f79}\label{class_c_bloom_filter_aec420a9b66ab133090c2b4b8ed286f79}} 
bool \mbox{\hyperlink{class_c_bloom_filter_aec420a9b66ab133090c2b4b8ed286f79}{Is\+Relevant\+And\+Update}} (const \mbox{\hyperlink{class_c_transaction}{C\+Transaction}} \&tx)
\begin{DoxyCompactList}\small\item\em Also adds any outputs which match the filter to the filter (to match their spending txes) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_bloom_filter_af98b43e91c82a1e4afc7454e8c5672c2}\label{class_c_bloom_filter_af98b43e91c82a1e4afc7454e8c5672c2}} 
void \mbox{\hyperlink{class_c_bloom_filter_af98b43e91c82a1e4afc7454e8c5672c2}{Update\+Empty\+Full}} ()
\begin{DoxyCompactList}\small\item\em Checks for empty and full filters to avoid wasting cpu. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_bloom_filter_aac1b6a065059e07177ec836929190ad0}\label{class_c_bloom_filter_aac1b6a065059e07177ec836929190ad0}} 
{\bfseries A\+D\+D\+\_\+\+S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+E\+T\+H\+O\+DS}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Bloom\+Filter is a probabilistic filter which S\+PV clients provide so that we can filter the transactions we sends them.

This allows for significantly more efficient transaction and block downloads.

Because bloom filters are probabilistic, an S\+PV node can increase the false-\/ positive rate, making us send them transactions which aren\textquotesingle{}t actually theirs, allowing clients to trade more bandwidth for more privacy by obfuscating which keys are owned by them. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_c_bloom_filter_a6395cfcb278ed9cf4ae873549c996f83}\label{class_c_bloom_filter_a6395cfcb278ed9cf4ae873549c996f83}} 
\index{C\+Bloom\+Filter@{C\+Bloom\+Filter}!C\+Bloom\+Filter@{C\+Bloom\+Filter}}
\index{C\+Bloom\+Filter@{C\+Bloom\+Filter}!C\+Bloom\+Filter@{C\+Bloom\+Filter}}
\subsubsection{\texorpdfstring{C\+Bloom\+Filter()}{CBloomFilter()}}
{\footnotesize\ttfamily C\+Bloom\+Filter\+::\+C\+Bloom\+Filter (\begin{DoxyParamCaption}\item[{unsigned int}]{n\+Elements,  }\item[{double}]{n\+F\+P\+Rate,  }\item[{unsigned int}]{n\+Tweak\+In,  }\item[{unsigned char}]{n\+Flags\+In }\end{DoxyParamCaption})}

Creates a new bloom filter which will provide the given fp rate when filled with the given number of elements Note that if the given parameters will result in a filter outside the bounds of the protocol limits, the filter created will be as close to the given parameters as possible within the protocol limits. This will apply if n\+F\+P\+Rate is very low or n\+Elements is unreasonably high. n\+Tweak is a constant which is added to the seed value passed to the hash function It should generally always be a random value (and is largely only exposed for unit testing) n\+Flags should be one of the B\+L\+O\+O\+M\+\_\+\+U\+P\+D\+A\+T\+E\+\_\+$\ast$ enums (not \+\_\+\+M\+A\+SK)

The ideal size for a bloom filter with a given number of elements and false positive rate is\+:
\begin{DoxyItemize}
\item n\+Elements $\ast$ log(fp rate) / ln(2)$^\wedge$2 We ignore filter parameters which will create a bloom filter larger than the protocol limits The ideal number of hash functions is filter size $\ast$ ln(2) / number of elements Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits See \href{https://en.wikipedia.org/wiki/Bloom_filter}{\tt https\+://en.\+wikipedia.\+org/wiki/\+Bloom\+\_\+filter} for an explanation of these formulas 
\end{DoxyItemize}

\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_c_bloom_filter_a06f2094da8e7d9c6ad4ea426858e32de}\label{class_c_bloom_filter_a06f2094da8e7d9c6ad4ea426858e32de}} 
\index{C\+Bloom\+Filter@{C\+Bloom\+Filter}!Is\+Within\+Size\+Constraints@{Is\+Within\+Size\+Constraints}}
\index{Is\+Within\+Size\+Constraints@{Is\+Within\+Size\+Constraints}!C\+Bloom\+Filter@{C\+Bloom\+Filter}}
\subsubsection{\texorpdfstring{Is\+Within\+Size\+Constraints()}{IsWithinSizeConstraints()}}
{\footnotesize\ttfamily bool C\+Bloom\+Filter\+::\+Is\+Within\+Size\+Constraints (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

True if the size is $<$= M\+A\+X\+\_\+\+B\+L\+O\+O\+M\+\_\+\+F\+I\+L\+T\+E\+R\+\_\+\+S\+I\+ZE and the number of hash functions is $<$= M\+A\+X\+\_\+\+H\+A\+S\+H\+\_\+\+F\+U\+N\+CS (catch a filter which was just deserialized which was too big) 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
P\+I\+V\+X/src/bloom.\+h\item 
P\+I\+V\+X/src/bloom.\+cpp\end{DoxyCompactItemize}
